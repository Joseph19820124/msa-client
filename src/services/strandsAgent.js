/**
 * Strands Agent SDK - AI-powered blog interaction agent
 * Provides intelligent automation for blog posts and comments
 */
import { postsApi, commentsApi } from './api';

class StrandsAgent {
  constructor(config = {}) {
    this.config = {
      postsServiceUrl: config.postsServiceUrl || process.env.REACT_APP_POSTS_SERVICE_URL || 'http://localhost:4000',
      commentsServiceUrl: config.commentsServiceUrl || process.env.REACT_APP_COMMENTS_SERVICE_URL || 'http://localhost:4001',
      agentName: config.agentName || 'Strands AI Agent',
      autoReply: config.autoReply || false,
      ...config
    };
    
    this.capabilities = [
      'post_analysis',
      'content_generation', 
      'comment_moderation',
      'trend_detection',
      'user_engagement'
    ];
    
    this.isActive = false;
    this.listeners = new Map();
  }

  /**
   * Initialize the agent and start monitoring
   */
  async initialize() {
    console.log(`ðŸ¤– Initializing ${this.config.agentName}...`);
    this.isActive = true;
    
    // Start monitoring for new posts and comments
    if (this.config.autoReply) {
      this.startMonitoring();
    }
    
    return {
      status: 'initialized',
      agent: this.config.agentName,
      capabilities: this.capabilities
    };
  }

  /**
   * Analyze content sentiment and extract key topics
   */
  analyzeContent(content) {
    const words = content.toLowerCase().split(/\s+/);
    const keyTopics = words.filter(word => word.length > 4);
    
    // Simple sentiment analysis based on common positive/negative words
    const positiveWords = ['good', 'great', 'awesome', 'amazing', 'excellent', 'fantastic', 'wonderful'];
    const negativeWords = ['bad', 'terrible', 'awful', 'horrible', 'disappointing', 'worst'];
    
    const positiveScore = words.filter(word => positiveWords.includes(word)).length;
    const negativeScore = words.filter(word => negativeWords.includes(word)).length;
    
    let sentiment = 'neutral';
    if (positiveScore > negativeScore) sentiment = 'positive';
    else if (negativeScore > positiveScore) sentiment = 'negative';
    
    return {
      sentiment,
      confidence: Math.abs(positiveScore - negativeScore) / words.length,
      keyTopics: [...new Set(keyTopics)].slice(0, 5),
      wordCount: words.length
    };
  }

  /**
   * Generate intelligent response based on post content
   */
  generateResponse(postTitle, postContent = '', context = {}) {
    const analysis = this.analyzeContent(postTitle + ' ' + postContent);
    const responses = {
      positive: [
        "Great post! This really resonates with current trends.",
        "Excellent insights! I'd love to see more content like this.",
        "Fantastic perspective on this topic. Thanks for sharing!"
      ],
      negative: [
        "Thanks for bringing this up. Have you considered alternative approaches?",
        "Interesting point. What solutions do you think might help?",
        "I appreciate you sharing this perspective."
      ],
      neutral: [
        "Thanks for sharing this post!",
        "Interesting topic. Looking forward to more discussions.",
        "Good to see diverse content on the platform."
      ]
    };
    
    const responsePool = responses[analysis.sentiment];
    const baseResponse = responsePool[Math.floor(Math.random() * responsePool.length)];
    
    // Add topic-specific insights
    let enhancedResponse = baseResponse;
    if (analysis.keyTopics.length > 0) {
      enhancedResponse += ` The topics around ${analysis.keyTopics[0]} are particularly relevant right now.`;
    }
    
    return {
      content: enhancedResponse,
      analysis,
      generatedBy: this.config.agentName,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Auto-comment on new posts based on agent configuration
   */
  async autoCommentOnPost(postId, postTitle, postContent = '') {
    if (!this.isActive || !this.config.autoReply) return null;
    
    try {
      const response = this.generateResponse(postTitle, postContent);
      
      // Add agent signature
      const commentContent = `${response.content}\n\n---\n*Comment generated by ${this.config.agentName} ðŸ¤–*`;
      
      const result = await commentsApi.createComment(
        this.config.commentsServiceUrl,
        postId,
        { content: commentContent }
      );
      
      console.log(`ðŸ¤– Auto-commented on post ${postId}`);
      return result.data;
    } catch (error) {
      console.error('Auto-comment failed:', error);
      return null;
    }
  }

  /**
   * Get posts with AI analysis
   */
  async getAnalyzedPosts() {
    try {
      const response = await postsApi.getPosts(this.config.postsServiceUrl);
      const posts = response.data;
      
      return posts.map(post => ({
        ...post,
        analysis: this.analyzeContent(post.title || ''),
        agentRecommendation: this.generateResponse(post.title || '').content
      }));
    } catch (error) {
      console.error('Failed to analyze posts:', error);
      return [];
    }
  }

  /**
   * Create AI-enhanced post
   */
  async createEnhancedPost(title, options = {}) {
    const enhancedTitle = options.enhanceTitle ? `âœ¨ ${title}` : title;
    const metadata = {
      createdBy: this.config.agentName,
      enhanced: true,
      timestamp: new Date().toISOString()
    };
    
    try {
      const result = await postsApi.createPost(this.config.postsServiceUrl, {
        title: enhancedTitle,
        metadata: JSON.stringify(metadata)
      });
      
      console.log(`ðŸ¤– Created enhanced post: ${enhancedTitle}`);
      return result.data;
    } catch (error) {
      console.error('Failed to create enhanced post:', error);
      throw error;
    }
  }

  /**
   * Monitor for new content and trigger agent actions
   */
  startMonitoring() {
    console.log('ðŸ” Starting content monitoring...');
    // This would typically connect to real-time updates
    // For demo purposes, we'll simulate periodic checks
  }

  /**
   * Stop the agent
   */
  stop() {
    this.isActive = false;
    console.log(`ðŸ›‘ ${this.config.agentName} stopped`);
  }

  /**
   * Get agent status and metrics
   */
  getStatus() {
    return {
      active: this.isActive,
      agent: this.config.agentName,
      capabilities: this.capabilities,
      config: {
        autoReply: this.config.autoReply,
        postsServiceUrl: this.config.postsServiceUrl,
        commentsServiceUrl: this.config.commentsServiceUrl
      }
    };
  }

  /**
   * Add event listener for agent actions
   */
  addEventListener(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(callback);
  }

  /**
   * Emit event to listeners
   */
  emit(event, data) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).forEach(callback => callback(data));
    }
  }
}

export default StrandsAgent;

// Factory function for creating agent instances
export const createStrandsAgent = (config) => new StrandsAgent(config);

// Pre-configured agent instances
export const blogAssistantAgent = createStrandsAgent({
  agentName: 'Blog Assistant',
  autoReply: true
});

export const moderatorAgent = createStrandsAgent({
  agentName: 'Content Moderator',
  autoReply: false
});